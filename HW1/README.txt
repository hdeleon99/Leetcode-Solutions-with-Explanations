Number 1: Two Sum
- For a brute force solution we can use two for loops, one nested within the other. We will have two indeces for iterating, left and right. Start left off at 0, and start right off at 1. Sum the values of nums[left] and nums[right] within the nested loop. If they equal target, return the indeces [left, right]. If they do not sum to the target, move right to the right by iterating the nested loop. Sum again. Repeat until r index reaches the length of the nums array or until target has been found. After right has reached the end of the array, move the left pointer to the right by iterating the first loop. Sum the results of num[left] and nums[right] and compare to target, returning [left, right] if they are equal. If not equal to target, iterate the first loop until sum is found, repeating until left has reached the length of the nums array - 1. This has a worst case complexity of O(N^2)

Number 2: Find First and Last Position of Element in Sorted Array
- We will use a left and a right variable to slide the "window" of the array to the left or to the right, and we will also utilize a boolean variable to determine in which direction to search after the first instance of target has been found. Set the left variable to 0, and the right variable to the length of the array - 1. Define and intialize an answer variable to -1, so that if the result is not found, -1 is returned. We will execute the following so long as the left pointer is not greater than the right pointer: calculate the midpoint using the left and right variables, midpoint = (left+right)//2, ensuring the result is rounded down. Compare nums[midpoint] to the target. If they are equal, assign the answer variable to the value of midpoint, and determine what the boolean leftSearch is. If it is true, assign the right pointer to the left of midpoint by 1 to begin the process of searching for the second instance of the variable to the LEFT. If leftSearch is false, we will search for the next instance of target to the right of the midpoint. If the element at the midpoint does not equal the target to begin with, evaluate whether the element at midpoint is greater than or less than the target. If it is less than, move the left pointer to the right of the midpoint by 1. If the element at midpoint is greater than the target, move the right variable to the left of midpoint by 1. Repeat until left > right, and return the answer variable. Because we are utilizing the Binary Search algorithm, this has a complexity of O(log n)
